<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Centers of Perception Mind Map</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Essential styles for D3 visualization */
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #f0f0f5; }
        .node circle { 
            fill: #fff; 
            stroke: steelblue; 
            stroke-width: 3px; 
            cursor: pointer; /* Indicates interactivity */
        }
        .node text { 
            font: 12px sans-serif; 
            fill: #555; 
            transition: opacity 0.5s; 
        }
        .link { 
            fill: none; 
            stroke: #ccc; 
            stroke-width: 2px;
            transition: all 0.5s; 
        }
        
        /* Tooltip style */
        .tooltip {
            position: absolute;
            text-align: left;
            padding: 8px;
            font: 12px sans-serif;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #aaa;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            max-width: 300px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* --- LEGEND STYLING --- */
        #legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            z-index: 10; /* Ensure it floats above the SVG */
            font-family: sans-serif;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 10px;
            border: 1px solid #333; /* Border for visibility */
        }
        .legend-item span {
            font-size: 14px;
            color: #333;
        }
    </style>
</head>
<body>
    
    <div id="legend">
        <strong>Primary Centers</strong>
        <hr style="margin: 5px 0;">
        {% for item in legend_data %}
        <div class="legend-item">
            <div class="legend-color" style="background-color: {{ item.color }};"></div>
            <span>{{ item.name }}</span>
        </div>
        {% endfor %}
    </div>

    <svg id="mindmap-container"></svg>
    <div class="tooltip"></div>

<script>
    // --- 1. SETUP DIMENSIONS & INITIALIZATION ---
    const width = window.innerWidth;
    const height = window.innerHeight;

    // FIX: Increased left margin to 150 to push the visualization right
    const margin = {top: 20, right: 50, bottom: 20, left: 150}; 
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;

    const svg = d3.select("#mindmap-container")
        .attr("width", width)
        .attr("height", height)
        .append("g")
        .attr("transform", `translate(${margin.left}, ${margin.top})`);

    const tree = d3.tree()
        .size([innerHeight, innerWidth]);

    const linkGenerator = d3.linkHorizontal()
        .x(d => d.y)
        .y(d => d.x);

    let i = 0;
    let duration = 750;
    let root; 

    // --- 2. CORE INTERACTION FUNCTIONS ---

    // Toggles children visibility
    function toggle(d) {
        if (d.children) {
            d._children = d.children;
            d.children = null;
        } else {
            d.children = d._children;
            d._children = null;
        }
    }

    // Updates the visualization after a collapse/expand event
    function update(source) {
        const treeData = tree(root);
        const nodes = treeData.descendants().reverse();
        const links = treeData.links();

        // FIX: Increased depth spacing to 250 for better horizontal separation
        nodes.forEach(d => { d.y = d.depth * 250; });

        // --- NODES (Enter, Update, Exit) ---
        const node = svg.selectAll("g.node")
            .data(nodes, d => d.id || (d.id = ++i));

        const nodeEnter = node.enter().append("g")
            .attr("class", "node")
            .attr("transform", d => `translate(${source.y0}, ${source.x0})`)
            .on("click", (event, d) => { 
                if (d.children || d._children) { 
                    toggle(d); 
                    update(d); 
                }
            }); 

        nodeEnter.append("circle")
            .attr("r", 1e-6)
            .attr("stroke", d => d.depth === 1 ? d.data.color : "steelblue")
            .attr("stroke-width", 3)
            .style("fill", d => d._children ? d.data.color : "#fff");

        nodeEnter.append("text")
            .attr("dy", "0.31em")
            .attr("x", d => d.children || d._children ? -10 : 10)
            .attr("text-anchor", d => d.children || d._children ? "end" : "start")
            .text(d => d.data.name)
            .attr("font-weight", d => d.depth === 1 ? "bold" : "normal") 
            .attr("fill", d => d.depth === 1 ? d.data.color : "#555") 
            .attr("opacity", 0); 
            
        // Apply Tooltip Logic to ALL nodes
        const tooltip = d3.select(".tooltip");
        nodeEnter
            .on("mouseover", function(event, d) {
                if (d.data.value) { 
                    d3.select(this).select("circle")
                        .attr("r", 8)
                        .attr("stroke-width", 5)
                        .attr("stroke", d.data.color || "green"); 

                    tooltip
                        .style("opacity", 1)
                        .html(`<strong>${d.data.name}:</strong> ${d.data.value}`)
                        .style("left", (event.pageX + 15) + "px")
                        .style("top", (event.pageY - 10) + "px");
                }
            })
            .on("mouseout", function(event, d) {
                d3.select(this).select("circle")
                    .attr("r", 5)
                    .attr("stroke-width", 3)
                    .attr("stroke", d => d.depth === 1 ? d.data.color : "steelblue");
                tooltip.style("opacity", 0);
            });

        // Transition nodes to their new position
        const nodeUpdate = node.merge(nodeEnter).transition()
            .duration(duration)
            .attr("transform", d => `translate(${d.y}, ${d.x})`);

        // Update circle style
        nodeUpdate.select("circle")
            .attr("r", 5)
            .style("fill", d => d._children ? d.data.color : "#fff") 
            .attr("cursor", d => d.children || d._children ? "pointer" : "default"); 

        // Update text style
        nodeUpdate.select("text")
            .attr("opacity", 1);
            
        // Transition exiting nodes
        const nodeExit = node.exit().transition()
            .duration(duration)
            .attr("transform", d => `translate(${source.y}, ${source.x})`)
            .remove();

        nodeExit.select("circle").attr("r", 1e-6);
        nodeExit.select("text").attr("opacity", 1e-6);

        // --- LINKS (Enter, Update, Exit) ---
        const link = svg.selectAll("path.link")
            .data(links, d => d.target.id);

        const linkEnter = link.enter().insert("path", "g")
            .attr("class", "link")
            .attr("d", d => {
                const o = {x: source.x0, y: source.y0};
                return linkGenerator({source: o, target: o});
            });

        link.merge(linkEnter).transition()
            .duration(duration)
            .attr("d", linkGenerator);

        link.exit().transition()
            .duration(duration)
            .attr("d", d => {
                const o = {x: source.x, y: source.y};
                return linkGenerator({source: o, target: o});
            })
            .remove();

        // Stash the old positions for transition
        nodes.forEach(d => {
            d.x0 = d.x;
            d.y0 = d.y;
        });
    }

    // --- 3. INITIAL LOAD ---
    d3.json("{{ url_for('api_data') }}").then(data => {
        root = d3.hierarchy(data, d => d.children);
        root.x0 = innerHeight / 2;
        root.y0 = 0;

        // Collapse all secondary nodes (Spouse, Work, etc.) initially
        if (root.children) {
            root.children.forEach(c => {
                if (c.children) {
                    c.children.forEach(toggle); 
                }
            });
        }
        
        update(root);
    });
</script>

</body>
</html>
